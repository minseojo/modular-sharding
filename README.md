# MySQL 기반 대용량 분산처리(Sharding 기법)에 대한 연구

## 프로젝트 소개
960만 개의 로그 데이터를 대상으로 모듈러 샤딩 알고리즘을 적용해 조회 쿼리 성능을 비교하고, 각 샤드 수(1, 2, 3개)에 따른 성능 차이를 분석한 프로젝트
인덱스 레인지 스캔, 풀 테이블 스캔, 커버링 인덱스가 쿼리 성능에 미치는 영향을 평가하고, 순차 탐색과 랜덤 탐색에서 성능 변화를 분석했으며, 이를 통해 샤딩의 의미를 명확히 하고, 성능 분석 결과를 쉽게 이해할 수 있도록 웹페이지로 구현하여 시연했습니다.

</br>

## 개발 기간 및 일정
+ 2024.03.25(월) ~ 2024.06.10(월)
+ MySQL, 샤딩 알고리즘 학습
+ 아키텍쳐, ERD 설계
+ 스프링부트 MySQL 연동
+ 중간 발표
+ '틸론'과 줌 회의 진행
+ 모듈러 샤딩 적용, 성능 테스트
+ 테스트 웹페이지 제작
+ 최종 발표

</br>

## 기술 스택
- 언어 : Java (JDK 11+), JavaScript
- 프레임워크 : Spring Boot 3.2.5
- 데이터베이스 : MySQL 8.0.29
- 라이브러리 : Thymeleaf, Lombok
- 테스트 및 성능 도구 : JMeter

</br>

## ERD
<img width="800" alt="스크린샷 2024-09-14 오후 10 29 24" src="https://github.com/user-attachments/assets/1fb0fb32-f9b6-48a4-91b6-d00b256aa2d9">

</br>
</br>

## 시스템 구성도
<img width="800" alt="스크린샷 2024-09-14 오후 10 28 14" src="https://github.com/user-attachments/assets/172b4f96-077d-4775-9bdf-d69f1d93f6d2">

</br>
</br>

## 테스트 환경 및 테스트 계획
### **테스트 환경**

- CPU – Intell Xenon Gold 6134 (8코어 16스레드, 3.2GHz)
- RAM – 8GB
- 운영체제 – Windows 11
- 소프트웨어 – MySQL, IntelliJ, Spring Boot
- 네트워크 – 다운로드 속도 : 477.76Mb/s, 업로드 속도 : 486.43Mb/s

### 테스트 계획
- 960만개의 데이터를 **조회(SELECT)했을 때의** 성능 비교
    - **테스트 쿼리**에 대해 **로그 데이터 개수**와 **샤드 수**에 따른 **응답 시간을 비교함**
        - 예시.
        - 샤드가 1개인 경우: 테이블 1개에 960만개 데이터
        - 샤드가 2개인 경우: 테이블 2개에 각각 480만 데이터
        - 샤드가 3개인 경우: 테이블 3개에 각각 320만 데이터
- **테스트 쿼리 구분 요소**
    - 테이블 **접근 방식**: **`순차 접근`**, **`랜덤 접근`**
    - 테이블 **스캔 방식**: **`풀 테이블 스캔`**, **`인덱스 레인지 스캔`**, **`커버링 인덱스`**

</br>

## 테스트 결과
### [순차 접근] 960만개의 데이터를 로그 ID 기준으로 10% / 25% / 50% / 100%의 구간별로 나눠서 테스트

<img width="1000" alt="스크린샷 2024-09-14 오후 10 30 56" src="https://github.com/user-attachments/assets/3b3ed235-c88a-495e-be39-c05612353332">

- **왼쪽 쿼리:** 인덱스 레인지 스캔 + 커버링 인덱스 적용
- **오른쪽 쿼리:** 인덱스 레인지 스캔만 적용
- **결과**: 커버링 인덱스 적용 시 `최소 2.6배`, `최대 5배` 향상
    - 96만개의 데이터에서 조회하는 경우 2.6배 차이가 나지만, 960만개 데이터에서 쿼리를 실행하는 경우 5배 향상
        - 따라서 비교하는 데이터가 많을수록 커버링 인덱스 효과가 많은 영향을 끼치는 사실을 알 수 있음
    - 샤딩과 결합된 경우 커버링 인덱스의 성능 향상 효과는 최대 1.4배 향상
 
    - 또한, 데이터 탐색 시작 위치(맨앞, 중간, 맨 뒤)의 차이는 미미했음.

</br>

### 커버링 인덱스 여부 분석
<img width="1000" alt="스크린샷 2024-09-14 오후 10 31 05" src="https://github.com/user-attachments/assets/4d391023-29b8-488d-bc64-8158f0af35d4">

- **왼쪽 쿼리:** 로그  ID 기준 데이터 순차 접근 (인덱스 레인지 스캔 및 커버링 인덱스 적용)
- **오른쪽 쿼리:** 로그  ID 기준 데이터 순차 접근 (인덱스 레인지 스캔 적용)
- **결과**: 커버링 인덱스가 적용 된 경우, 샤드 수가 늘어날수록 성능 차이가 줄어듬 => 커버링 인덱스가 적용 된 경우에는 샤딩의 효과가 많은 영향을 끼치지 않음
    -  위의 결과에서 볼 수 있듯이, 960만 개의 데이터에서 커버링 인덱스를 적용했을 때 샤드를 1개 사용할 경우보다 3개 사용할 경우 최대 2배의 성능 향상이 나타났다.

</br>

### 지정된 날짜 1분 / 10분 / 1시간 사이에 생성된 로그 데이터 조회
<img width="1000" alt="스크린샷 2024-09-14 오후 10 31 12" src="https://github.com/user-attachments/assets/326893e1-cf22-4bb4-82ae-d3ad017e84da">


- **왼쪽 쿼리:** 날짜 기준, 테이블 풀 스캔 및 조회 컬럼 1개
- **오른쪽 쿼리:** 날짜 기준, 테이블 풀 스캔 및 조회 컬럼 5개
- **결과**:
    - 테이블 풀 스캔은 전체 데이터를 읽기 때문에 특정 시간 구간에 관계없이 모든 데이터를 스캔한다. 하지만 반환되는 데이터의 양은 쿼리에서 선택한 컬럼 수(`logId`만 조회하거나 `*`로 여러 컬럼을 조회)와 결과의 크기에 따라 차이가 나며, 이로 인해 최종 반환 시간에 차이가 발생한다.
    - 또한 샤드가 증가할수록 데이터가 여러 샤드에 분할되기 때문에 각 샤드에서 처리해야 할 데이터 양이 줄어든다. 따라서 테이블 풀 스캔을 하더라도, 샤드가 많아지면 개별 샤드에서 처리하는 데이터가 적어지기 때문에 조회 시간이 감소한다.

</br>

### 인덱스 레인지 스캔 VS 테이블 풀 스캔
<img width="1000" alt="스크린샷 2024-09-14 오후 10 31 19" src="https://github.com/user-attachments/assets/abf719e8-43f8-49e2-9296-a9b4b647b9d5">

- **왼쪽 쿼리:** 로그  ID 기준 데이터 순차 접근 (인덱스 레인지 스캔)
    - 이 쿼리는 `log_id` 컬럼에 인덱스가 적용된 상태에서 `인덱스 레인지 스캔 방식`으로 데이터를 조회한다. 인덱스 레인지 스캔은 **필요한 범위의 데이터만 효율적으로 조회**할 수 있어 샤딩 대비 성능이 많이 개선되지 않는다.
- **오른쪽 쿼리:** 날짜 기준 데이터 순차 접근 (테이블 풀 스캔)
    - 이 쿼리는 `created_at` 컬럼에 인덱스가 없기 때문에 `테이블 풀 스캔 방식`으로 데이터를 조회한다. 테이블 풀 스캔은 **테이블 전체를 읽어오기 때문에** 처리해야 하는 데이터 양이 많아질수록 조회 시간이 오래 걸린다.
    - 따라서 차트를 보면, 샤드가 증가할수록 각 샤드에서 처리해야 할 데이터 양이 줄어들기 때문에 조회 시간이 **인덱스 레인지 스캔 방식에 비해 감소**하는 것을 확인할 수 있다.
    

- **결과:** 테이블 풀 스캔 쿼리가 인덱스 레인지 스캔하는 쿼리보다 샤딩의 효과가 명확하다.

</br>

### [랜덤 접근]서버 ID(샤드키)로 로그 정보 조회 - 조회 컬럼 개수여부에 따른 차이
<img width="1000" alt="스크린샷 2024-09-14 오후 10 31 27" src="https://github.com/user-attachments/assets/095dae18-f249-4a63-9406-40144af1e734">

- **왼쪽 쿼리:** 조회 컬럼 개수 1개 (logId)
- **오른쪽 쿼리:** 조회 컬럼 개수 5개 (*)
- **결과**: `샤드키(server_id)`를 사용하여 데이터를 분할하면 샤드의 수가 증가할수록 각 샤드에서 처리할 데이터가 줄어들어 조회 시간이 줄어듭니다. 또한, 조회하는 컬럼의 개수에 따라 처리 시간이 달라지며, 샤딩을 통해 성능이 크게 개선될 수 있습니다

-   #### 샤드 개수에 따른 차이가 나타나는 이유 (샤드키)
<img width="500" alt="스크린샷 2024-09-14 오후 10 32 39" src="https://github.com/user-attachments/assets/acb8c728-6505-4a70-aa61-026a7ff1a1fc">

- 샤드가 3개인 경우, 각 샤드에는 데이터가 320만개씩 있으며, 이를 8개 코어 기준 3개의 샤드를 모두 병렬로 실행하기 때문에 약 3배 성능이 향상된다.

</br>
</br>

### [랜덤 접근] 조인 연산
<img width="1000" alt="스크린샷 2024-09-14 오후 10 33 11" src="https://github.com/user-attachments/assets/f240cd5d-90de-4903-8a2c-c54c12c977c5">

- **결과:** 모든 쿼리는 server_id를 샤드키로 사용하여 데이터를 분산했기 때문에 샤드 수가 많아질수록 조회 시간이 줄어듭니다.
또한, 조회하는 데이터의 양에 따라 조회 시간이 달라지며, 특히 유저가 사용하는 모든 서버의 모든 로그 데이터를 조회하는 경우 가장 많은 시간이 소요됩니다.
샤딩을 통해 데이터 양이 분산되면 성능이 크게 향상되는 것을 확인할 수 있습니다.


</br>


## 팀원 소개
+ 조민서(팀장)
+ 지수영
+ 박태성
+ 황성헌

